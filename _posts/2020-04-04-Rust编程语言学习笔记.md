---
layout:     post
title:      Rust学习笔记
subtitle:   主体是《Rust编程语言》的学习记录，部分其他关于Rust的学习记录
date:       2020-04-04
author:     zondie
header-img: img/2020-04-04/bg.jpg
catalog: true
tags:
    - Rust, Programm
---

## 第二章 项目eg

`crate`是一个rust代码包。

我们正在构建的项目是一个<u>二进制crate</u>，它生成一个可执行文件。

`cargo.lock`文件确保构建是可重建的。

`let`、`match`、方法、关联函数、使用外部crate

## 第三章 语言基础

#### 3.1 变量与可变性

**变量与可变性**

变量默认是不可改变的。

若要可变，变量名前加`mut`。

**变量和常量的区别**

不循序对常量使用`mut`。常量不光默认不可变，它总是不能变的。

声明常量使用关键字`const`而非`let`，并且必须注明值的类型。

常量只能被设置为常量表达式，而不能是函数调用的结果。

Rust常量的命名规范是使用下划线分割的大写字母单词，并且可以在数字字面值中插入下划线来提升可读性。

**隐藏**

可以定义一个与之前变量同名的新变量，而新变量会**隐藏**之前的变量。

可以使用相同变量名称来隐藏一个变量，以及重复使用`let`来多次隐藏。

当再次使用`let`时，实际上创建了一个新变量，我们可以改变值的类型，但复用这个名字。

#### 3.2 数据类型

**数据类型**

两类数据类型子集：标量和复合。

**Rust是静态类型语言。**

1. 整形

   整形溢出 依赖溢出被认为是一种错误。

2. 浮点型

3. 布尔类型

4. 字符类型

Rust的`char`类型代表了一个Unicode标量值，这意味着它可以比ASCII表示更多内容。

**复合类型**

可以讲多个值组合成一个类型。有两个原生的复合类型：元组和数组。

Rust中的数组是固定长度的：一旦声明，长度不能增长或缩小。

Rust会检查数组索引访问是否正确。

#### 3.3 函数如何工作

**函数**

`fn`用来声明新函数。

**Rust代码中的函数和变量名规格风范：所有字母都是小写并使用下划线分割单词。**

Rust中不关心函数定义位置。

**函数参数**

在函数签名中，必须声明每个参数的类型。

**包含语句和表达式的函数体**

Rust是一门给予表达式的语言。

语句是执行一些操作但是不返回值的指令。表达式计算并产生一个值。

函数调用是一个表达式，宏调用是一个表达式。

如果在表达式的结尾加上分号，它就变成了语句，而语句不会返回值。

**具有返回值的函数**

#### 3.4 注释

//

#### 3.5 控制流

`if`条件判断可以不加括号..另外必须总是显示地使用布尔值作为`if`的条件，不会尝试自动将非布尔值转换成布尔值。

## 第四章 认识所有权

所有权是Rust最独特的功能，它让Rust无需垃圾回收即可保障内存安全。

#### 4.1 什么是所有权

一些语言具有垃圾回收机制，在程序运行时不断的寻找不再使用的内存；在另一些语言中，程序员必须亲自分配和释放内存。Rust通过所有权系统管理内存，编译器在编译时会根据一系列的规则进行检查。

跟踪哪部分代码正在使用堆上的哪些数据，最大限度的减少堆上的重复数据的数量，以及清理堆上不再使用的数据确保不会耗尽空间。这些问题正是所有权系统要处理的。一旦理解了所有权，你就不需要经常考虑堆和栈了，不过明白了所有权的存在就是为了管理堆数据，能够帮助解释为什么所有权要以这种方式工作。

- 所有权规则

  1. Rust中的每个值都有一个被称为所有者的变量。
  2. 值有且只有一个所有者。
  3. 当所有者（变量）离开作用域，这个值将被丢弃。

- `String`类型

  `Rust`语言提供了两种字符串

  1. 字符串字面量`&str`，是`Rust`核心内置的数据类型
  2. 字符串对象`String`。不是`Rust`核心的一部分，只是`Rust`标准库中的一个公开`pub`结构体。

- 变量与数据交互的方式（一）：移动

  ```rust
  let s1 = String::from("hello");
  let s2 = s1;
  ```

  只是拷贝了栈上的指针、长度和容量，没有复制指针指向栈上数据。

  当`s2`、`s1`离开作用域时，会尝试释放相同的内存，这是一个叫做==二次释放==的错误。

  在`s2`被创建之后，`s1`被认为是不再有效的，只有`s2`是有效的，则离开作用域时，它就释放自己的内存。

  又被称为浅拷贝。

- 变量与数据交互的方式（一）：克隆

  深拷贝使用`clone`函数。

- 只在栈上的数据：拷贝

  编译时已知大小的数据被整个存储在栈上，其没有深浅拷贝的区别，不会无效。

  `Copy`类型：

  - 所有整数类型，如`u32`	
  - 布尔类型
  - 所有浮点数类型
  - 字符类型
  - 元组，当且仅当其包含的类型也都是`Copy`的时候

- 所有权与函数

  向函数传递值可能会移动或者复制。

  `String`移动到函数中之后，在函数之后`String`不再有效。

  而`Copy`类型则不受影响。

- 返回值与作用域

  返回值也可以转移所有权。

#### 4.2 引用与借用

&符号就是引用，允许使用值但不获取所有权。

引用离开作用域后并不丢弃它指向的数据，因为没有所有权。

我们将获取引用作为函数参数称为借用。

- 可变引用

  在特定作用域的特定数据有且只有一个可变引用。

  可以在编译时就避免数据竞争。

  数据竞争：

  - 两个或更多指针同时访问同一数据
  - 至少有一个指针被用来写入数据
  - 没有同步数据访问的机制

  可以用大括号来创建一个新的作用域，以便拥有多个可变引用。

  不能在拥有不可变引用的同时拥有可变引用。

- 垂悬引用

  垂悬指针是指其指向的内存可能已经被分配给其他持有者。

  `rust`编译器确保数据不会在其引用之前离开作用域。

- 引用的规则

  - 在任意给定时间，要么只能有一个可变引用，要么只能有多个不可变引用
  - 引用必须总是有效的

  ==有点神奇的是==

  事实上，在访问这些引用之前，编译器对于引用的规则似乎是不加限制的，即可以同时存在多个可变引用或多个可变引用夹杂多个不可变引用的情况，只要不访问这些引用。甚至于说，只要访问最后一个类型的第一个引用都是被允许的。。即若`A`表示可变引用，`B`表示不可变引用时；

  ```bash
  AAAABBBAAABBAAABAABAAA
  ```

  这种情况时，访问倒数第三个`A`都是被允许的。应当也可以理解，在这种情况下，之前所有引用没有被访问过，也就没有了数据出现同时访问/修改的危险。不过于此对应的是，一个函数如果出现`dangling reference`类似情况但并没有被引用过时，都不能被编译器通过。这两者区别是什么？

#### 4.3 Slices

另一个没有所有权的数据类型是`slice`

字符串`slice`是`String`中一部分值的引用

- 字符串字面值就是`slice`
- 其他类型的`slice`

## 第五章 使用结构体来组织相关联的数据

#### 5.1 定义并实例化结构体

定义结构体，需要使用`struct`关键字并为整个结构体提供一个名字。

通过为**每个**字段指定具体值来创建结构体的实例。

`rust`不允许只将某个字段标记为可变。

- 结构体更新语法

- 使用没有命名字段的元祖结构体来创建不同的类型

  与元组类似的结构体，元组结构体。

- 没有任何字段的类单元结构体

  没有任何字段的结构体，称为类单元结构体。常常在你想要在某个类型上实现`trait`但不需要在类型中存储数据的时候发挥作用。

#### 5.2 一个使用结构体的事例程序

`Rust`包含了打印出调试信息的功能，不过必须为结构体显示选择这个功能。为此， 在结构体定义之前加上`#[derive(Debug)]`注解。

另外打印时，用`{:?}`或`{:#?}`。

#### 5.3 方法语法

方法在结构体的上下文中被定义，并且它们的第一个参数总是`self`，表示调用该方法的结构体事例。

- 定义方法

  通过仅仅使用`self`作为第一个参数来使用方法获取实例的所有权是很少见的；这种技术通常用在当方法将`self`转换成别的实例的时候，这时我们想要防止调用者在转换之后使用原始的实例。

  `Rust`有一个叫**<u>自动引用和解引用</u>**的功能。方法调用是`Rust`中少数几个拥有这种行为的地方。

  他是这样工作的：当使用 `object.something()` 调用方法时，Rust 会自动为 `object`添加 `&`、`&mut` 或 `*` 以便使 `object` 与方法签名匹配。

- 带有更多参数的方法

  第一个参数是`&self`，后面的和函数类似

- 关联函数

  `impl`块另外允许在块中定义不以`self`作为参数的函数。这被称为关联函数，因为它们与结构体相关联，他们仍是函数而不是方法，因为它们并不作用于一个结构体的实例。

  使用结构体名和`::`语法来调用关联函数。其位于结构体的命名空间中：`::`语法用于关联函数和模块创建的空间。

  将特定函数置于结构体的命名空间中并且无需一个实例。

- 多个`impl`块

## 第六章 枚举与模式匹配

枚举，也被称为`enums`。

#### 6.1 定义枚举

枚举可以把一群不同的结构体糅合在一起。

- `Option`枚举和其相对于空值的优势

  `Option`是标准库定义的另一个枚举，即一个值要么有值要么没值。

  `Rust`并没有很多其他语言中有的空值功能。空值是一个值，它代表没有值

  不再担心会错误的假设一个非空值

#### 6.2 `match`控制流运算符

- `match`控制流运算符

- 绑定值的模式

  匹配分支的另一个有用的功能是可以绑定匹配的模式的部分值。

- 匹配`Option`

- 匹配`Some(T)`

  将`match`与枚举相结合在很多场景中都是有用的。

  `match`一个枚举，绑定其中的值到一个变量，接着根据其值执行代码。

- 匹配是穷尽的

  必须穷举到最后的可能性来使代码有效。

- `_`通配符

  （我感觉类似于`switch`里的`default`）

  ` _ `模式会匹配所有的值。通过将其放置于其他分支之后，`_`将会匹配所有之前没有指定的可能的值。

#### 6.3 `if let`简介控制流

- `if let`简单控制流

  工作方式与`match`相同，可以认为`if let`是`match`的一个语法糖，它当值匹配某一模式时执行代码而忽略所有其他值。

- 总结

  现在我们涉及到了如何使用枚举来创建有一系列可列举值的自定义类型。我们也展示了标准库的 `Option` 类型是如何帮助你利用类型系统来避免出错的。当枚举值包含数据时，你可以根据需要处理多少情况来选择使用 `match` 或 `if let` 来获取并使用这些值。

  你的 Rust 程序现在能够使用结构体和枚举在自己的作用域内表现其内容了。在你的 API 中使用自定义类型保证了类型安全：编译器会确保你的函数只会得到它期望的类型的值。

## 第七章 包管理

#### 7.0 包、`crate`与模块

#### 7.1 包和crate用来创建库和二进制项目

- `crate`是一个二进制或库项目
- `crate`根是一个用来描述如何构建`crate`的文件
- 带有`Cargo.toml`文件的包用以描述如何构建一个或多个`crate`。一个包中至多可以有一个库项目。

#### 7.2 模块系统用来控制作用域和私有性

- 路径用来引用模块树中的项

  - 绝对路径

    从`crate`根开始，以`crate`名或者字面值`crate`开头。

  - 相对路径

    从当前模块开始，以`self`、`super`或当前模块的标识符开头。

- 模块作为私有性的边界

  - 所有项（函数、方法、结构体、枚举、模块和常量）默认是私有的
  - 可以使用`pub`关键字使项变共有
  - 不允许使用定义于当前模块的自模块中的私有代码
  - 允许使用任何定义于父模块或当前模块中的代码

- 使用`pub`关键字使项变为公有

- 使用`super`开始相对路径

- 对结构体和枚举使用`pub`

  在结构体定义中使用`pub`，可以使结构体公有，但是结构体的字段仍然是私有的。

  相反，如果有一个公有枚举，其所有成员都是公有。

- 使用`use`关键字将名称引入作用域

- `use`函数路径使用习惯VS其他项

  对于函数来说，通过`use`制定函数的父模块接着制定父模块来调用方法被认为是习惯用法。

  对于结构体、枚举和其他项，通过`use`指定项的全路径是习惯用法。

- 通过`as`关键字重命名引入作用域的类型

  将两个同名类型引入作用域的一个解决方法：在`use`后加上`as`和另一个新名称来为此类型制定一个新的本地名称。

- 通过`pub use`重导出名称

  当使用`use`关键字将名称导入作用域时，在新作用域中可用的名称是私有的。如果希望调用你编写的代码的代码能够像你一样在其作用域内引用这些类型，可以用重导出`pub use`

- 使用外部包

  标准库(`std`)对于你的包来说也是外部`crate`。

- 嵌套路径来消除大量的`use`行

- 通过`glob`运算符将所有的公有定义引入作用域

- 将模块分割进不同文件

## 第八章 集合

#### 8.0 通用集合类型

1. vector
2. 字符串string
3. 哈希map

#### 8.1 vector用来存储一系列的值

- 新建vector

  `vec！`宏，根据提供的值来创建一个新的`Vec`。

- 更新vector

  `mut`

- 丢弃vector时也会丢弃其所有元素

- 读取vector的元素

  有两种方法引用vector中存储的值。

  - 使用`&`和`[]`来返回一个引用
  - 使用`get`方法以索引作为参数来返回一个`Option<&T>`

  程序可以选择如何处理当索引值在vector中没有对应值的情况。

  作用域中不能同时存在可变和不可变引用，故而获取来vector一个元素的同时是不能给其添加元素的。

  vector的工作方式：在vector的结尾增加新元素时，在没有足够空间将所有元素依次相邻存放的时候，可能会要求分配新内存并将老的元素拷贝到新的空间中。这样的话上述中提到的不可变引用就指向了被释放的内存。

- 遍历vector中的元素

- 使用枚举来存储多种类型

  创建一个存储枚举值的vector，就能存储不同类型的值了。

#### 8.2 使用字符串存储UTF-8编码的文本

- 什么是字符串

  提到`rust`的字符串时，通常指的是`String`会让字符串slicr`&str`类型，而不仅仅是其中之一。

- 新建字符串

  可以使用`to_string`方法，能用于任何实现了`Display`trait的类型。

- 更新字符串

  - `push_str`方法获取字符串slice，不需要获取参数的所有权。

  - `push`方法被定义为获取一个单独的字符作为参数。

  - 使用`+`运算符

    之所以能够在`add`调用中使用`&s2`是因为`&String`可以被强制成`&str`。当`add`函数被调用时，`Rust`使用了一个被称为解引用强制多态的技术。

  - `format`宏

    不会获取任何参数的所有权

- 索引字符串

  在很多语言中，通过索引来引用字符串中的单独字符是有效且常见的操作。

  但在`rust`中是不成的..

- 内部表现

  `String`是一个`Vec<u8>`的封装。其中存储的是`UTF-8`编码。而一个`Unicode`标量值需要两个字节存储，但一个英文字母只要一个字节。

- 字节、标量值和字形簇

  三种相关方式理解字符串。

- 字符串`slice`

- 遍历字符串的方法

  - `"hello".chars()`
  - `"hello".bytes()`

- 字符串并不简单

  程序员们必须更多的思考如何预先处理UTF-8数据。

#### 8.3 哈希map

- 哈希map储存键值对

  `HashMap<K, V>`

- 新建一个哈希map

- 哈希map和所有权

  一旦键值对被插入后就称为哈希map所拥有

- 更新哈希map

  - 覆盖 直接插入
  - 只在键没有对应值的时候插入 `entry`
  - 根据旧值更新一个值 

## 第九章 错误处理

#### 9.1 `panic!`与不可恢复的错误

painc程序默认会展开，即`Rust`回溯栈并清理所遇到的每一个函数的数据；另一种可以直接终止，不清理数据就推出数据。

- 使用`panic!`的backtrace

#### 9.2 `Result`与可恢复的错误

`unwrap`

`expect`









